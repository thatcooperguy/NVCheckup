//go:build linux

package remediate

import (
	"fmt"
	"os"

	"github.com/nicholasgasior/nvcheckup/pkg/types"
)

// nouveauBlacklistPath is the file path for the nouveau blacklist modprobe config.
const nouveauBlacklistPath = "/etc/modprobe.d/blacklist-nouveau.conf"

// nouveauBlacklistContent is the content written to blacklist the nouveau driver.
const nouveauBlacklistContent = `# Generated by NVCheckup - blacklist nouveau to allow NVIDIA proprietary driver
blacklist nouveau
options nouveau modeset=0
`

// actionBlacklistNouveau creates a modprobe configuration file that prevents the
// open-source nouveau driver from loading, which is required for the proprietary
// NVIDIA driver to function correctly. This action requires root privileges and
// a reboot (or initramfs rebuild) to take effect.
func (e *Engine) actionBlacklistNouveau() (output, undoInfo string, err error) {
	// Check if the blacklist file already exists and capture its content for undo
	if _, statErr := os.Stat(nouveauBlacklistPath); statErr == nil {
		existing, readErr := os.ReadFile(nouveauBlacklistPath)
		if readErr == nil {
			return fmt.Sprintf("Blacklist file already exists at %s", nouveauBlacklistPath),
				string(existing), nil
		}
	}

	// Write the blacklist configuration file using a shell command through
	// the executor so that all file system writes are mockable in tests.
	// We use "sh -c" with a heredoc-style echo to write the content.
	_, writeErr := e.executor.Run("sh", "-c",
		fmt.Sprintf("printf '%%s' '%s' > %s",
			nouveauBlacklistContent, nouveauBlacklistPath))
	if writeErr != nil {
		return "", "", fmt.Errorf("failed to write %s: %w", nouveauBlacklistPath, writeErr)
	}

	return fmt.Sprintf("Created %s. Reboot required for changes to take effect. "+
		"You may also need to run 'update-initramfs -u' or 'dracut -f'.", nouveauBlacklistPath),
		nouveauBlacklistPath, // undo info = file path to remove
		nil
}

// actionUpdateLdconfig runs ldconfig to refresh the shared library cache. This is
// often needed after installing or updating NVIDIA drivers to ensure libcuda.so
// and other NVIDIA libraries are properly registered.
func (e *Engine) actionUpdateLdconfig() (output, undoInfo string, err error) {
	ldOutput, err := e.executor.Run("ldconfig")
	if err != nil {
		return ldOutput, "", fmt.Errorf("ldconfig failed: %w", err)
	}

	return fmt.Sprintf("ldconfig completed successfully: %s", ldOutput),
		"", // ldconfig is idempotent; no meaningful undo
		nil
}

// applyAction dispatches a remediation action by ID to the appropriate
// Linux-specific implementation.
func (e *Engine) applyAction(id string) (output string, undoInfo string, err error) {
	switch id {
	case "blacklist-nouveau":
		return e.actionBlacklistNouveau()
	case "update-ldconfig":
		return e.actionUpdateLdconfig()
	default:
		return "", "", fmt.Errorf("unknown remediation action: %q", id)
	}
}

// undoAction reverses a previously applied Linux remediation action using
// the stored undo information.
func (e *Engine) undoAction(id string, undoInfo string) error {
	switch id {
	case "blacklist-nouveau":
		// undoInfo contains the file path to remove, or the previous file contents
		// if the file already existed before we modified it.
		if undoInfo == nouveauBlacklistPath {
			// We created the file; undo by removing it
			return os.Remove(undoInfo)
		}
		// The file existed before; restore its original contents
		return os.WriteFile(nouveauBlacklistPath, []byte(undoInfo), 0644)

	case "update-ldconfig":
		// ldconfig is idempotent; running it again is the "undo"
		_, err := e.executor.Run("ldconfig")
		return err

	default:
		return fmt.Errorf("unknown action for undo: %q", id)
	}
}

// getAvailableActions returns the list of remediation actions available on Linux.
func getAvailableActions() []types.RemediationAction {
	return []types.RemediationAction{
		{
			ID:          "blacklist-nouveau",
			Title:       "Blacklist nouveau driver",
			Description: "Creates /etc/modprobe.d/blacklist-nouveau.conf to prevent the open-source nouveau driver from loading, allowing the proprietary NVIDIA driver to work correctly.",
			Risk:        types.RiskMedium,
			NeedsAdmin:  true,
			NeedsReboot: true,
			Platform:    "linux",
			Category:    "driver",
			RelatedFind: "nouveau driver is loaded",
		},
		{
			ID:          "update-ldconfig",
			Title:       "Refresh shared library cache (ldconfig)",
			Description: "Runs ldconfig to update the dynamic linker cache. This ensures NVIDIA libraries (libcuda.so, libnvidia-ml.so) are findable by applications.",
			Risk:        types.RiskLow,
			NeedsAdmin:  true,
			NeedsReboot: false,
			Platform:    "linux",
			Category:    "driver",
			RelatedFind: "libcuda.so not found in library path",
		},
	}
}
